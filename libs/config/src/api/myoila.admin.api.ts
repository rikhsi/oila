//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.7.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

export interface ITranslationApiService {
    textTranslator(translationRequestModel: TranslationRequestModel): Observable<ResponseDataOfString>;
}

@Injectable({
    providedIn: 'root'
})
export class TranslationApiService implements ITranslationApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    textTranslator(translationRequestModel: TranslationRequestModel): Observable<ResponseDataOfString> {
        let url_ = this.baseUrl + "/api/admin/Translation/TextTranslator";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(translationRequestModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processTextTranslator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processTextTranslator(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfString>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfString>;
        }));
    }

    protected processTextTranslator(response: HttpResponseBase): Observable<ResponseDataOfString> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfString;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISellerAccountApiService {
    registerSeller(sellerRegisterRequest: SellerRegisterRequestModel): Observable<ResponseDataOfResponseSuccess>;
    activateAccount(activateUserRequest: ActivateUserRequestModel): Observable<ResponseDataOfTokenResponseModel>;
    resendActivationCode(email?: string | undefined): Observable<ResponseDataOfResponseSuccess>;
}

@Injectable({
    providedIn: 'root'
})
export class SellerAccountApiService implements ISellerAccountApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    registerSeller(sellerRegisterRequest: SellerRegisterRequestModel): Observable<ResponseDataOfResponseSuccess> {
        let url_ = this.baseUrl + "/api/admin/SellerAccount/RegisterSeller";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(sellerRegisterRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegisterSeller(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterSeller(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfResponseSuccess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfResponseSuccess>;
        }));
    }

    protected processRegisterSeller(response: HttpResponseBase): Observable<ResponseDataOfResponseSuccess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfResponseSuccess;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    activateAccount(activateUserRequest: ActivateUserRequestModel): Observable<ResponseDataOfTokenResponseModel> {
        let url_ = this.baseUrl + "/api/admin/SellerAccount/ActivateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(activateUserRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processActivateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processActivateAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfTokenResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfTokenResponseModel>;
        }));
    }

    protected processActivateAccount(response: HttpResponseBase): Observable<ResponseDataOfTokenResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfTokenResponseModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resendActivationCode(email?: string | undefined): Observable<ResponseDataOfResponseSuccess> {
        let url_ = this.baseUrl + "/api/admin/SellerAccount/ResendActivationCode?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResendActivationCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResendActivationCode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfResponseSuccess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfResponseSuccess>;
        }));
    }

    protected processResendActivationCode(response: HttpResponseBase): Observable<ResponseDataOfResponseSuccess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfResponseSuccess;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICategoriesApiService {
    create(createDto: CategoryCreateDTO): Observable<ResponseDataOfInteger>;
    getAll(zorroFilter: ZorroFilterRequest): Observable<ResponseDataOfPageListOfCategoryDTO>;
    getById(id: number): Observable<ResponseDataOfCategoryDTO>;
    getByIdWithDetails(id: number): Observable<ResponseDataOfCategoryWithDetailsDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class CategoriesApiService implements ICategoriesApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(createDto: CategoryCreateDTO): Observable<ResponseDataOfInteger> {
        let url_ = this.baseUrl + "/api/admin/Categories/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfInteger>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfInteger>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseDataOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfInteger;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(zorroFilter: ZorroFilterRequest): Observable<ResponseDataOfPageListOfCategoryDTO> {
        let url_ = this.baseUrl + "/api/admin/Categories/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(zorroFilter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfPageListOfCategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfPageListOfCategoryDTO>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ResponseDataOfPageListOfCategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfPageListOfCategoryDTO;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: number): Observable<ResponseDataOfCategoryDTO> {
        let url_ = this.baseUrl + "/api/admin/Categories/GetById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfCategoryDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfCategoryDTO>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResponseDataOfCategoryDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfCategoryDTO;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getByIdWithDetails(id: number): Observable<ResponseDataOfCategoryWithDetailsDTO> {
        let url_ = this.baseUrl + "/api/admin/Categories/GetByIdWithDetails/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetByIdWithDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetByIdWithDetails(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfCategoryWithDetailsDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfCategoryWithDetailsDTO>;
        }));
    }

    protected processGetByIdWithDetails(response: HttpResponseBase): Observable<ResponseDataOfCategoryWithDetailsDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfCategoryWithDetailsDTO;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ICharacteristicsApiService {
    create(createDto: CharacteristicCreateDTO): Observable<ResponseDataOfInteger>;
    getAll(zorroFilter: ZorroFilterRequest): Observable<ResponseDataOfPageListOfCharacteristicDTO>;
    getById(id: number): Observable<ResponseDataOfCharacteristicDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class CharacteristicsApiService implements ICharacteristicsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(createDto: CharacteristicCreateDTO): Observable<ResponseDataOfInteger> {
        let url_ = this.baseUrl + "/api/admin/Characteristics/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfInteger>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfInteger>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseDataOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfInteger;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(zorroFilter: ZorroFilterRequest): Observable<ResponseDataOfPageListOfCharacteristicDTO> {
        let url_ = this.baseUrl + "/api/admin/Characteristics/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(zorroFilter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfPageListOfCharacteristicDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfPageListOfCharacteristicDTO>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ResponseDataOfPageListOfCharacteristicDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfPageListOfCharacteristicDTO;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: number): Observable<ResponseDataOfCharacteristicDTO> {
        let url_ = this.baseUrl + "/api/admin/Characteristics/GetById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfCharacteristicDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfCharacteristicDTO>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResponseDataOfCharacteristicDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfCharacteristicDTO;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IOptionsApiService {
    create(createDto: OptionCreateDTO): Observable<ResponseDataOfInteger>;
    getById(id: number): Observable<ResponseDataOfOptionDTO>;
    getAll(zorroFilter: ZorroFilterRequest): Observable<ResponseDataOfPageListOfOptionDTO>;
}

@Injectable({
    providedIn: 'root'
})
export class OptionsApiService implements IOptionsApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    create(createDto: OptionCreateDTO): Observable<ResponseDataOfInteger> {
        let url_ = this.baseUrl + "/api/admin/Options/Create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(createDto);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfInteger>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfInteger>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<ResponseDataOfInteger> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfInteger;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getById(id: number): Observable<ResponseDataOfOptionDTO> {
        let url_ = this.baseUrl + "/api/admin/Options/GetById/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfOptionDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfOptionDTO>;
        }));
    }

    protected processGetById(response: HttpResponseBase): Observable<ResponseDataOfOptionDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfOptionDTO;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAll(zorroFilter: ZorroFilterRequest): Observable<ResponseDataOfPageListOfOptionDTO> {
        let url_ = this.baseUrl + "/api/admin/Options/GetAll";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(zorroFilter);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfPageListOfOptionDTO>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfPageListOfOptionDTO>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<ResponseDataOfPageListOfOptionDTO> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfPageListOfOptionDTO;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IAccountApiService {
    login(login: LoginRequestModel): Observable<ResponseDataOfTokenResponseModel>;
    refreshToken(refreshToken?: string | undefined): Observable<ResponseDataOfTokenResponseModel>;
    logout(refreshToken?: string | undefined): Observable<ResponseDataOfResponseSuccess>;
    resetPassword(resetPasswordRequestModel: ResetPasswordRequestModel): Observable<ResponseDataOfTokenResponseModel>;
    sendRequestToResetPassword(email?: string | undefined): Observable<ResponseDataOfResponseSuccess>;
}

@Injectable({
    providedIn: 'root'
})
export class AccountApiService implements IAccountApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    login(login: LoginRequestModel): Observable<ResponseDataOfTokenResponseModel> {
        let url_ = this.baseUrl + "/api/admin/Account/Login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(login);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfTokenResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfTokenResponseModel>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<ResponseDataOfTokenResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfTokenResponseModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshToken(refreshToken?: string | undefined): Observable<ResponseDataOfTokenResponseModel> {
        let url_ = this.baseUrl + "/api/admin/Account/RefreshToken?";
        if (refreshToken === null)
            throw new Error("The parameter 'refreshToken' cannot be null.");
        else if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfTokenResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfTokenResponseModel>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<ResponseDataOfTokenResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfTokenResponseModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    logout(refreshToken?: string | undefined): Observable<ResponseDataOfResponseSuccess> {
        let url_ = this.baseUrl + "/api/admin/Account/Logout?";
        if (refreshToken === null)
            throw new Error("The parameter 'refreshToken' cannot be null.");
        else if (refreshToken !== undefined)
            url_ += "refreshToken=" + encodeURIComponent("" + refreshToken) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogout(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfResponseSuccess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfResponseSuccess>;
        }));
    }

    protected processLogout(response: HttpResponseBase): Observable<ResponseDataOfResponseSuccess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfResponseSuccess;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetPassword(resetPasswordRequestModel: ResetPasswordRequestModel): Observable<ResponseDataOfTokenResponseModel> {
        let url_ = this.baseUrl + "/api/admin/Account/ResetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetPasswordRequestModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfTokenResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfTokenResponseModel>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<ResponseDataOfTokenResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfTokenResponseModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    sendRequestToResetPassword(email?: string | undefined): Observable<ResponseDataOfResponseSuccess> {
        let url_ = this.baseUrl + "/api/admin/Account/SendRequestToResetPassword?";
        if (email === null)
            throw new Error("The parameter 'email' cannot be null.");
        else if (email !== undefined)
            url_ += "email=" + encodeURIComponent("" + email) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendRequestToResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendRequestToResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfResponseSuccess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfResponseSuccess>;
        }));
    }

    protected processSendRequestToResetPassword(response: HttpResponseBase): Observable<ResponseDataOfResponseSuccess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfResponseSuccess;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IRolePermissionApiService {
    createRole(roleRequestModel: RoleRequestModel): Observable<ResponseDataOfRoleResponseModel>;
    updateRole(roleRequestModel: RoleRequestModel): Observable<ResponseDataOfRoleResponseModel>;
    getAllRoles(zorroFilterRequest: ZorroFilterRequest): Observable<ResponseDataOfPageListOfRoleResponseModel>;
    deleteRole(id?: number | undefined): Observable<ResponseDataOfResponseSuccess>;
    setRoleToUser(userAndRole: UserAndRoleIdRequestModel): Observable<ResponseDataOfResponseSuccess>;
    getRoleById(id?: number | undefined): Observable<ResponseDataOfRoleResponseModel>;
    getUserPermissions(userId?: number | undefined): Observable<PermissionModel[]>;
    getAllPermissions(): Observable<PermissionModel[]>;
    getEnumPermissons(enumPermission?: EnumPermission | undefined): Observable<string>;
    getEnumRoles(enumPermission?: EnumRole | undefined): Observable<string>;
}

@Injectable({
    providedIn: 'root'
})
export class RolePermissionApiService implements IRolePermissionApiService {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    createRole(roleRequestModel: RoleRequestModel): Observable<ResponseDataOfRoleResponseModel> {
        let url_ = this.baseUrl + "/api/admin/RolePermission/CreateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleRequestModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfRoleResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfRoleResponseModel>;
        }));
    }

    protected processCreateRole(response: HttpResponseBase): Observable<ResponseDataOfRoleResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfRoleResponseModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateRole(roleRequestModel: RoleRequestModel): Observable<ResponseDataOfRoleResponseModel> {
        let url_ = this.baseUrl + "/api/admin/RolePermission/UpdateRole";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(roleRequestModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfRoleResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfRoleResponseModel>;
        }));
    }

    protected processUpdateRole(response: HttpResponseBase): Observable<ResponseDataOfRoleResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfRoleResponseModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllRoles(zorroFilterRequest: ZorroFilterRequest): Observable<ResponseDataOfPageListOfRoleResponseModel> {
        let url_ = this.baseUrl + "/api/admin/RolePermission/GetAllRoles";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(zorroFilterRequest);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfPageListOfRoleResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfPageListOfRoleResponseModel>;
        }));
    }

    protected processGetAllRoles(response: HttpResponseBase): Observable<ResponseDataOfPageListOfRoleResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfPageListOfRoleResponseModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteRole(id?: number | undefined): Observable<ResponseDataOfResponseSuccess> {
        let url_ = this.baseUrl + "/api/admin/RolePermission/DeleteRole?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteRole(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteRole(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfResponseSuccess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfResponseSuccess>;
        }));
    }

    protected processDeleteRole(response: HttpResponseBase): Observable<ResponseDataOfResponseSuccess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfResponseSuccess;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setRoleToUser(userAndRole: UserAndRoleIdRequestModel): Observable<ResponseDataOfResponseSuccess> {
        let url_ = this.baseUrl + "/api/admin/RolePermission/SetRoleToUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userAndRole);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetRoleToUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetRoleToUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfResponseSuccess>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfResponseSuccess>;
        }));
    }

    protected processSetRoleToUser(response: HttpResponseBase): Observable<ResponseDataOfResponseSuccess> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfResponseSuccess;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getRoleById(id?: number | undefined): Observable<ResponseDataOfRoleResponseModel> {
        let url_ = this.baseUrl + "/api/admin/RolePermission/GetRoleById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRoleById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRoleById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ResponseDataOfRoleResponseModel>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ResponseDataOfRoleResponseModel>;
        }));
    }

    protected processGetRoleById(response: HttpResponseBase): Observable<ResponseDataOfRoleResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseDataOfRoleResponseModel;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getUserPermissions(userId?: number | undefined): Observable<PermissionModel[]> {
        let url_ = this.baseUrl + "/api/admin/RolePermission/GetUserPermissions?";
        if (userId === null)
            throw new Error("The parameter 'userId' cannot be null.");
        else if (userId !== undefined)
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionModel[]>;
        }));
    }

    protected processGetUserPermissions(response: HttpResponseBase): Observable<PermissionModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PermissionModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getAllPermissions(): Observable<PermissionModel[]> {
        let url_ = this.baseUrl + "/api/admin/RolePermission/GetAllPermissions";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPermissions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPermissions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PermissionModel[]>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PermissionModel[]>;
        }));
    }

    protected processGetAllPermissions(response: HttpResponseBase): Observable<PermissionModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PermissionModel[];
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEnumPermissons(enumPermission?: EnumPermission | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/admin/RolePermission/GetEnumPermissons?";
        if (enumPermission === null)
            throw new Error("The parameter 'enumPermission' cannot be null.");
        else if (enumPermission !== undefined)
            url_ += "enumPermission=" + encodeURIComponent("" + enumPermission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumPermissons(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumPermissons(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetEnumPermissons(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getEnumRoles(enumPermission?: EnumRole | undefined): Observable<string> {
        let url_ = this.baseUrl + "/api/admin/RolePermission/GetEnumRoles?";
        if (enumPermission === null)
            throw new Error("The parameter 'enumPermission' cannot be null.");
        else if (enumPermission !== undefined)
            url_ += "enumPermission=" + encodeURIComponent("" + enumPermission) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetEnumRoles(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetEnumRoles(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<string>;
                }
            } else
                return _observableThrow(response_) as any as Observable<string>;
        }));
    }

    protected processGetEnumRoles(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ResponseDataOfString {
    result?: string | undefined;
    error?: ResponseError | undefined;
}

export interface ResponseError {
    code: number;
    message?: string | undefined;
}

export interface TranslationRequestModel {
    translationTechnology: TranslateTechEnum;
    from: string;
    to: string;
    text: string;
}

export enum TranslateTechEnum {
    Google2 = 0,
    Google = 1,
    Bing = 2,
    Microsoft = 3,
    Yandex = 4,
}

export interface ResponseDataOfResponseSuccess {
    result?: ResponseSuccess | undefined;
    error?: ResponseError | undefined;
}

export interface ResponseSuccess {
    success: boolean;
}

export interface SellerRegisterRequestModel {
    password: string;
    email: string;
}

export interface ResponseDataOfTokenResponseModel {
    result?: TokenResponseModel | undefined;
    error?: ResponseError | undefined;
}

export interface TokenResponseModel {
    accessToken: string;
    refreshToken: string;
    expires: number;
    permissions: string;
}

export interface ActivateUserRequestModel {
    email: string;
    code: string;
}

export interface ResponseDataOfInteger {
    result: number;
    error?: ResponseError | undefined;
}

export interface CategoryCreateDTO {
    name: MultiLanguageField;
    parentId?: number | undefined;
    options: CategoryOptionCreateDTO[];
    characteristicIds: number[];
}

export interface MultiLanguageField {
    uz?: string | undefined;
    ru?: string | undefined;
}

export interface CategoryOptionCreateDTO {
    optionId: number;
    isRequired: boolean;
}

export interface ResponseDataOfPageListOfCategoryDTO {
    result?: PageListOfCategoryDTO | undefined;
    error?: ResponseError | undefined;
}

export interface PageListOfCategoryDTO {
    pageIndex: number;
    pageSize: number;
    total: number;
    pageTotal: number;
    filteredTotal: number;
    items?: CategoryDTO[] | undefined;
}

export interface CategoryDTO {
    id: number;
    name: string;
    children: CategoryDTO[];
    parent?: CategoryDTO | undefined;
}

export interface ZorroFilterRequest {
    pageIndex: number;
    pageSize: number;
    sort?: ZorroSort[] | undefined;
    filter?: ZorroFilter[] | undefined;
}

export interface ZorroSort {
    key?: string | undefined;
    value: ZorroSortEnum;
}

export enum ZorroSortEnum {
    Asc = 0,
    Desc = 1,
}

export interface ZorroFilter {
    key?: string | undefined;
    value?: any | undefined;
}

export interface ResponseDataOfCategoryDTO {
    result?: CategoryDTO | undefined;
    error?: ResponseError | undefined;
}

export interface ResponseDataOfCategoryWithDetailsDTO {
    result?: CategoryWithDetailsDTO | undefined;
    error?: ResponseError | undefined;
}

export interface CategoryWithDetailsDTO {
    id: number;
    name: MultiLanguageField;
    children: CategoryDTO[];
    parent?: CategoryDTO | undefined;
}

export interface CharacteristicCreateDTO {
    name: MultiLanguageField;
    terms: CharacteristicTermCreateDTO[];
}

export interface CharacteristicTermCreateDTO {
    name: MultiLanguageField;
}

export interface ResponseDataOfPageListOfCharacteristicDTO {
    result?: PageListOfCharacteristicDTO | undefined;
    error?: ResponseError | undefined;
}

export interface PageListOfCharacteristicDTO {
    pageIndex: number;
    pageSize: number;
    total: number;
    pageTotal: number;
    filteredTotal: number;
    items?: CharacteristicDTO[] | undefined;
}

export interface CharacteristicDTO {
    id: number;
    name: MultiLanguageField;
    terms: CharacteristicTermDTO[];
}

export interface CharacteristicTermDTO {
    name: MultiLanguageField;
}

export interface ResponseDataOfCharacteristicDTO {
    result?: CharacteristicDTO | undefined;
    error?: ResponseError | undefined;
}

export interface OptionCreateDTO {
    name: MultiLanguageField;
    terms: OptionTermCreateDTO[];
    optionType: EnumOptionType;
    viewType: EnumOptionViewType;
}

export interface OptionTermCreateDTO {
    name: MultiLanguageField;
    additional: string;
    order: number;
}

export enum EnumOptionType {
    Selectable = 1,
    Custom = 2,
}

export enum EnumOptionViewType {
    Button = 1,
    Color = 2,
}

export interface ResponseDataOfOptionDTO {
    result?: OptionDTO | undefined;
    error?: ResponseError | undefined;
}

export interface OptionDTO {
    id: number;
    name: MultiLanguageField;
    terms: OptionTermDTO[];
}

export interface OptionTermDTO {
    id: number;
    name: MultiLanguageField;
    additional: string;
    order: number;
}

export interface ResponseDataOfPageListOfOptionDTO {
    result?: PageListOfOptionDTO | undefined;
    error?: ResponseError | undefined;
}

export interface PageListOfOptionDTO {
    pageIndex: number;
    pageSize: number;
    total: number;
    pageTotal: number;
    filteredTotal: number;
    items?: OptionDTO[] | undefined;
}

export interface LoginRequestModel {
    login: string;
    password: string;
    deviceId: string;
}

export interface ResetPasswordRequestModel {
    email: string;
    code: string;
    password: string;
}

export interface ResponseDataOfRoleResponseModel {
    result?: RoleResponseModel | undefined;
    error?: ResponseError | undefined;
}

export interface RoleResponseModel {
    id: number;
    name: string;
    permissions?: PermissionModel[] | undefined;
}

export interface PermissionModel {
    id: number;
    name: string;
}

export interface RoleRequestModel {
    id?: number | undefined;
    name: string;
    permissionIds?: number[] | undefined;
}

export interface ResponseDataOfPageListOfRoleResponseModel {
    result?: PageListOfRoleResponseModel | undefined;
    error?: ResponseError | undefined;
}

export interface PageListOfRoleResponseModel {
    pageIndex: number;
    pageSize: number;
    total: number;
    pageTotal: number;
    filteredTotal: number;
    items?: RoleResponseModel[] | undefined;
}

export interface UserAndRoleIdRequestModel {
    userId: number;
    roleId: number;
}

export enum EnumPermission {
    CreateSp = 1,
    UpdateSp = 2,
    DeleteSp = 3,
    GetSp = 4,
    CreateCategory = 6,
    UpdateCategory = 7,
    DeleteCategory = 8,
    GetCategory = 9,
    CreateBusiness = 10,
    UpdateBusiness = 11,
    DeleteBusiness = 12,
    GetBusiness = 13,
    GetUsers = 14,
    BlockUser = 15,
    UnlockUser = 16,
    DeleteUser = 17,
    CreateUser = 18,
    UpdateUser = 19,
    CreateRole = 20,
    UpdateRole = 21,
    DeleteRole = 22,
    GetRole = 23,
}

export enum EnumRole {
    Admin = 1,
    Moderator = 2,
    Seller = 3,
    Client = 4,
}

export class SwaggerException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}